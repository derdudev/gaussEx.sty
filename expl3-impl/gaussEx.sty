\ProvidesPackage{gaussEx}[2025/03/11]
\RequirePackage{amsmath}
\RequirePackage{expl3}

\ExplSyntaxOn
%
% VARIABLES
%
% Boxes
\box_new:N \g__gex_trash
\box_new:N \g__gex_matrixbox
\box_new:N \g__gex_eastbox
\box_new:N \g__gex_northbox
\box_new:N \g__gex_centerbox % NEW
\box_new:N \g__gex_label
\box_new:N \g__gex_tmp_box
\box_new:N \g__gex_tmpa_box
\box_new:N \g__gex_tmpb_box
% TeX helper boxes
\newbox\l__gex_tmp_tex_box

% Integers
\int_new:N \g__gex_maxrow
\int_new:N \g__gex_maxcol
\int_new:N \g__gex_maxrow_old
\int_new:N \g__gex_maxcol_old
\int_new:N \g__gex_tmp_int % in gauss: g@c@tmp
\int_new:N \g__gex_tmpa_int % g@c@tmpa

% Dimensions
\dim_new:N \g__gex_axis_height
\dim_new:N \g__gex_linethickness
\dim_new:N \g__gex_tab
\dim_new:N \g__gex_arrowht
\dim_new:N \g__gex_arrowwd
\dim_new:N \g__gex_tmp_dim
\dim_new:N \g__gex_tmpa_dim
\dim_new:N \g__gex_tmpb_dim
\dim_new:N \g__gex_tmpc_dim
\dim_new:N \g__gex_tmpd_dim
\dim_new:N \g__gex_tmpe_dim
\dim_new:N \g__gex_matrix_wd
\dim_new:N \g__gex_matrix_ht
\dim_new:N \g__gex_matrix_dp

% Token lists
\tl_new:N \l__gex_environment 

% Variables for keys 
\cs_new:Npn \l__gex_opt_rowmultlabel #1 { |\,#1 } 
\cs_new:Npn \l__gex_opt_rowswapfromlabel #1 { } 
\cs_new:Npn \l__gex_opt_rowswaptolabel #1 { } 
\cs_new:Npn \l__gex_opt_rowaddfromlabel #1 { \scriptstyle #1 } 
\cs_new:Npn \l__gex_opt_rowaddtolabel #1 { \scriptscriptstyle + } 
\cs_new:Npn \l__gex_opt_colmultlabel #1 { 
    \underline{\hbox to 1.2em{$\hss\mathstrut{}#1\hss$}}
} 
\cs_new:Npn \l__gex_opt_colswapfromlabel #1 { } 
\cs_new:Npn \l__gex_opt_colswaptolabel #1 { }
\cs_new:Npn \l__gex_opt_coladdfromlabel #1 { \scriptstyle #1 }
\cs_new:Npn \l__gex_opt_coladdtolabel #1 { \scriptscriptstyle + }

\dim_new:N \l__gex_opt_rowarrowsep 
\dim_new:N \l__gex_opt_colarrowsep 
\dim_new:N \l__gex_opt_rowopminsize 
\dim_new:N \l__gex_opt_colopminsize 

% CAUTION: the following two options are badly named as they are dimensions and not skips!
\dim_new:N \l__gex_opt_opskip 
\dim_new:N \l__gex_opt_labelskip 

% Local environment options
\tl_new:N \l__gex_envopt_cols
\tl_new:N \l__gex_envopt_rows

% Environment specifier
\bool_new:N \l__gex_in_env 

% Defaults for the dimension and skip options (could also be set as .default:n in \key_define:nn but for performance reasons, the defaults are set here)
\dim_set:Nn \l__gex_opt_rowarrowsep { .5em }
\dim_set:Nn \l__gex_opt_colarrowsep { .5em }
\dim_set:Nn \l__gex_opt_colopminsize { 3pt }
\dim_set:Nn \l__gex_opt_rowopminsize { 3pt }

\dim_set:Nn \l__gex_opt_opskip { 5pt }
\dim_set:Nn \l__gex_opt_labelskip { 4pt }

% Key definitions
\keys_define:nn { gex } {
    % Control sequences: gauss.sty macros with one arguments
    rowmultlabel .cs_set:Np     = \l__gex_opt_rowmultlabel #1,
    rowswapfromlabel .cs_set:Np = \l__gex_opt_rowswapfromlabel #1,
    rowswaptolabel .cs_set:Np   = \l__gex_opt_rowswaptolabel #1,
    rowaddfromlabel .cs_set:Np  = \l__gex_opt_rowaddfromlabel #1,
    rowaddtolabel .cs_set:Np    = \l__gex_opt_rowaddtolabel #1,
    colmultlabel .cs_set:Np     = \l__gex_opt_colmultlabel #1,
    colswapfromlabel .cs_set:Np = \l__gex_opt_colswapfromlabel #1,
    colswaptolabel .cs_set:Np   = \l__gex_opt_colswaptolabel #1,
    coladdfromlabel .cs_set:Np  = \l__gex_opt_coladdfromlabel #1,
    coladdtolabel .cs_set:Np    = \l__gex_opt_coladdtolabel #1,
    % gauss.sty TeX dimensions 
    rowarrowsep .dim_set:N  = \l__gex_opt_rowarrowsep,
    colarrowsep .dim_set:N  = \l__gex_opt_colarrowsep,
    rowopminsize .dim_set:N = \l__gex_opt_rowopminsize,
    colopminsize .dim_set:N = \l__gex_opt_colopminsize,
    % gauss.sty TeX skips
    opskip .dim_set:N      = \l__gex_opt_opskip,
    labelskip .dim_set:N   = \l__gex_opt_labelskip,
    % Local environment keys
    cols .code:n = {
        \bool_if:nTF { \l__gex_in_env } {
            % Attempting to set the key in an gexmatrix environment context => permitted!
            \tl_set:Nn \l__gex_envopt_cols { #1 }
        } {
            % Attemting to set the keys in a context that is not tht gexmatrix environment => prohibited!
            \PackageWarning{gaussEx}{ The~ option~ "cols"~ can~ only~ be~ used~ as~ an~ environment~ option~ for~ the~ "gexmatrix"~ environment.~ You~ attempted~ to~ set~ it~ using~ \SetGexDefaults.~ Here~ the~ option~ will~ be~ ignored. }
        }
    },
    rows .code:n = {
        \bool_if:nTF { \l__gex_in_env } {
            % Attempting to set the key in an gexmatrix environment context => permitted!
            \tl_set:Nn \l__gex_envopt_rows { #1 }
        } {
            % Attemting to set the keys in a context that is not tht gexmatrix environment => prohibited!
            \PackageWarning{gaussEx}{ The~ option~ "rows"~ can~ only~ be~ used~ as~ an~ environment~ option~ for~ the~ "gexmatrix"~ environment.~ You~ attempted~ to~ set~ it~ using~ \SetGexDefaults.~ Here~ the~ option~ will~ be~ ignored. }
        }
    },
}

% TODO: \SetGexDefaults (and later \NewGexMatrix)
\NewDocumentCommand { \SetGexDefaults } { m } {
    \keys_define:nn { gex } {
        unknown .undefine:, 
        unknown .code:n = {
            % here, later add error handling for private env options (such as cols and rows)
            \exp_args:Ne \iow_log:n { The~ option~ "\l_keys_key_str"~ is~ unknown }
        }
    }
    \keys_set:nn { gex } {
        #1
    }
    \cs_log:N \l__gex_opt_rowmultlabel
    \dim_log:N \l__gex_opt_rowarrowsep
}

% 
% MATRIX CLASSES
%
\prop_new:N \l__gex_matrix_classes % use property lists instead of module keys as module keys are harder to create dynamically (then also the names for the corresponding tl variables would have to be dynamically generated, resulting in ugly code)

\NewDocumentCommand { \NewGexClass } { m m } {
    \prop_put:Nnn \l__gex_matrix_class { #1 } { #2 } % another advantage: \prop_put:Nnn automatically allows overriding!
}

% DEL: The \g@for macro does not need to be implemented as its functionality should be given by \int_step_inline

% Bounds check
\bool_new:N \g__gex_index_in_bounds
% Arguments:
%   #1: Either the token "r" or "c"; "r" causes an Row-Bounds-Error to be thrown, "c" causes an Colum-Bounds-Error to be thrown
%   #2: Integer 
%   #3: Integer
%   #4: Integer
% Function: Sets \g__gex_index_in_bounds to true if #2<=#3<=#4 and to false if not
\cs_new:Npn \__gex_check_bounds:nnnn #1#2#3#4 {
    \bool_set_false:N \g__gex_index_in_bounds
    % using \int_compare:nTF would result in clearer code, but a huge performance loss (5x slower that \int_compare:nNnTF)
    \int_compare:nNnTF {#2} > {#3} {
        \PackageError{gaussEx}{\__gex_short_bounds_error:n { #1 }~ #2>#3}{\__gex_long_bounds_error:n { #1 }}
    }{
        \int_compare:nNnTF {#3} > {#4} {
            \PackageError{gaussEx}{\__gex_short_bounds_error:n { #1 }~ #3>#4}{\__gex_long_bounds_error:n { #1 }}
        }{
            \bool_set_true:N \g__gex_index_in_bounds
        }
    }
}

% Arguments: 
%   #1: Either "r" (Row-Bounds-Error) or "c" (Column-Bounds-Error)
\cs_new:Npn \__gex_short_bounds_error:n #1 {
    \str_if_eq:nnTF { r } { #1 } { Row~ } { Column~ }
    index~ out~ of~ bounds:
}
% Arguments: 
%   #1: Either "r" (Row-Bounds-Error)) or "c" (Column-Bounds-Error)
\cs_new:Npn \__gex_long_bounds_error:n #1 {
    An~index~of~an~operation~points~to~a~
    \str_if_eq:nnTF { r } { #1 } { row~ } { column~ }
    that~ does~ not~ exist.\MessageBreak
    Note~ that~ the~ index~ of~ the~ 
    \str_if_eq:nnTF { r } { #1 } { bottom~ row~ } { leftmost~ column~ }
    is~ 0~ while~ the~ index~ of~ the~
    \str_if_eq:nnTF { r } { #1 } { top~ row~ } { rightmost~ column~ }
    is~ <number~ of~
    \str_if_eq:nnTF { r } { #1 } { rows~ } { columns~ } 
    -~ 1>.
}

%
% BUILD THE VERTICAL ARROW
%
\DeclareMathSymbol{\__gex_downarrow_symb:}{\mathord}{largesymbols}{`\y}
\DeclareMathSymbol{\__gex_vertline_symb:}{\mathord}{largesymbols}{`\?}
\cs_new:Npn \__gex_vertline: { \hbox:n { $\__gex_vertline_symb:$ }\kern-\lineskip }

% Arguments: 
%   #1: dim expression; the length of the arrow
% CAUTION: For this macro to not run infinitely, \g__gex_arrowht has to be non-zero!
\cs_new:Npn \__gex_downarrow:n #1 {
    \vbox:n {
        \vfill 
        \baselineskip0pt
        \dim_set:Nn \g__gex_tmpc_dim { #1 }
        \dim_compare:nNnTF { \g__gex_tmpc_dim } < { \g__gex_arrowht } {
            \dim_set_eq:NN \g__gex_tmpc_dim \g__gex_arrowht
        }{}
        \__gex_arrow_vline:
        \kern\dim_eval:n { \g__gex_tmpc_dim }
        \hbox_set:Nn \g__gex_trash { $\__gex_downarrow_symb:$ }
        \hbox:n { \box_move_up:nn { \box_dp:N \g__gex_trash } { \box_use:N \g__gex_trash } }
    }
}
\cs_new:Npn \__gex_arrow_vline: {
    \dim_sub:Nn \g__gex_tmpc_dim { \g__gex_arrowht }
    \dim_compare:nNnTF { \g__gex_tmpc_dim } < { 0pt } { } {
        \__gex_vertline:
        \__gex_arrow_vline:
    }
}

% DEL: \redo, \g@del (\dim_to_decimal), \g@defdim (\dim_set), \g@defdouble (\fp_set), \g@dim (\fp_to_dim), \g@double (\fp_eval:n, \dim_eval:n), \g@advance (\dim_add, \fp_add), \g@min (\dim_min and \fp_min), \g@minD , \g@max, \g@maxD, \g@dist (\dim_sub, \fp_sub), \g@distD, \g@update (replace as moving along), \g@updateArea (implement first later, then see)

\seq_new:N \g__gex_rx
\seq_new:N \g__gex_ry
\seq_new:N \g__gex_rb
\seq_new:N \g__gex_rt
\cs_new:Npn \__gex_measure_rows: {
    \box_set_to_last:N \g__gex_trash
    % \exp_args:Ne \iow_log:n { DURCHLAUF-\int_eval:n { \g__gex_maxrow } }
    % \box_log:N \g__gex_trash
    \int_compare:nNnTF { \g__gex_maxrow } < { 0 } {} {
        \dim_compare:nNnTF { \box_ht:N \g__gex_trash } = { 0pt } {
            \dim_add:Nn \g__gex_tmp_dim { \lastskip }
            % \dim_log:N \g__gex_tmp_dim
            \unskip
            \dim_add:Nn \g__gex_tmp_dim { \lastkern }
            \unkern
            \unpenalty
        }{
            \dim_add:Nn \g__gex_tmp_dim { \box_dp:N \g__gex_trash }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rb { \dim_eval:n { \g__gex_tmp_dim } }
            \dim_add:Nn \g__gex_tmp_dim { \g__gex_axis_height }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_ry { \dim_eval:n { \g__gex_tmp_dim } }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rx { \c_zero_dim }
            \dim_sub:Nn \g__gex_tmp_dim { \g__gex_axis_height }
            \dim_add:Nn \g__gex_tmp_dim { \box_ht:N \g__gex_trash }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rt { \dim_eval:n { \g__gex_tmp_dim } }
            \int_decr:N \g__gex_maxrow
        }
        \__gex_measure_rows:
    }
}

\seq_new:N \g__gex_cx
\seq_new:N \g__gex_cy
\seq_new:N \g__gex_ct
\cs_new:Npn \__gex_measure_cols: {
    \box_set_to_last:N \g__gex_trash
    \dim_compare:nNnTF { \box_wd:N \g__gex_trash } = { 100cm } {
        \int_gset:Nn \g__gex_maxcol { \g__gex_maxcol }
        \int_set:Nn \g__gex_tmp_int { \g__gex_maxcol - 1 }
        \seq_log:N \g__gex_ct
        \seq_log:N \g__gex_cy
        \__gex_measure_cols_succ:
        \int_gdecr:N \g__gex_maxcol
    }{
        \dim_compare:nNnTF { \box_ht:N \g__gex_trash } = { 0pt } {
            \dim_add:Nn \g__gex_tmp_dim { \lastskip }
            \unskip 
            \dim_add:Nn \g__gex_tmp_dim { \lastkern }
            \unkern 
            \unpenalty
        }{
            \exp_args:NNe \seq_gput_left:Nn \g__gex_ct { \dim_eval:n { \g__gex_tmp_dim } }
            \dim_set:Nn \g__gex_tmp_dim { 0pt }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_cy { \dim_eval:n { \box_wd:N \g__gex_trash } }
            \int_incr:N \g__gex_maxcol
        }
        \__gex_measure_cols:
    }
}

% TODO: Rework with \seq_map_inline
\cs_new:Npn \__gex_measure_cols_succ: {
    % \exp_args:Ne \iow_log:n { \int_eval:n \g__gex_tmp_int }
    \if_int_compare:w \g__gex_tmp_int < 0 \else:
        \seq_gpop_left:NN \g__gex_cy \l_tmp_tl 
        \dim_set:Nn \g__gex_tmpa_dim { \l_tmp_tl }
        \seq_gpop_left:NN \g__gex_ct \l_tmp_tl
        \dim_set:Nn \g__gex_tmpb_dim { \l_tmp_tl }
        \dim_add:Nn \g__gex_tmp_dim { .5\g__gex_tmpa_dim }
        \seq_gput_right:Nn \g__gex_cy { 0pt }
        \exp_args:NNe \seq_gput_right:Nn \g__gex_cx { \dim_eval:n { \g__gex_tmp_dim } }
        \dim_add:Nn \g__gex_tmp_dim { .5\g__gex_tmpa_dim }
        \dim_add:Nn \g__gex_tmp_dim { \g__gex_tmpb_dim }
        % \exp_args:Ne \iow_log:n { In~if:~\int_eval:n { \g__gex_tmp_int },~\int_eval:n { \g__gex_maxcol - 1 } }
        \int_compare:nNnTF { \g__gex_tmp_int } = { \g__gex_maxcol-1 } {
            % \exp_args:Ne \iow_log:n { In~if:~\int_eval:n \g__gex_tmp_int }
            \dim_add:Nn \g__gex_tmp_dim { .5\g__gex_tab }
        }{}
        \int_decr:N \g__gex_tmp_int
        \__gex_measure_cols_succ:
    \fi:
}

\cs_new:Npn \__gex_measure_axis: {
    % Calculate the distance of the math axis to the baseline
    \hbox_set:Nn \g__gex_trash { $\vcenter{\hbox to 5pt{}}$ }
    \dim_gset:Nn \g__gex_axis_height { \box_ht:N \g__gex_trash }

    % Calculate the width of a \leftarrow 
    \hbox_set:Nn \g__gex_trash { $\leftarrow$ }
    \dim_gset:Nn \g__gex_arrowwd { \box_wd:N \g__gex_trash }

    % Calculate the minimal width of a vertical arrow
    \vbox_set:Nn \g__gex_trash { \__gex_vertline: }
    \dim_gset:Nn \g__gex_arrowht { \box_ht_plus_dp:N \g__gex_trash }
    \dim_gadd:Nn \g__gex_arrowht { \lineskip }

    % Set thickness for all lines
    \dim_gset:Nn \g__gex_linethickness { \fboxrule\relax }
}

% Arguments:
%   #1: The sequence over the maximum over the index range {#2,...,#3} is calculated. The sequence is expected to contain token lists that can be evaluated as dim expressions by \dim_eval:n
%   #2: Start index of the range (inclusive)
%   #3: End index of the range (inclusive)
%   #4: dim variable into which the maximum will be saved
% Replacement for \g@measureArea
\cs_new:Npn \__gex_get_max_over_range:NnnN #1#2#3#4 {
    \dim_gset:Nn #4 { 0pt }
    \int_compare:nNnTF { #2 } = { #3 } {
        \dim_gset:Nn #4 { \seq_item:Nn #1 { #2 } }
    } {
        \int_compare:nNnTF { #2 } < { #3 } {
            \int_step_inline:nnn { #2 } { #3 } {
                \dim_gset:Nn #4 { \dim_max:nn { #4 } { \seq_item:Nn #1 { ##1 } } }
            }
        } {
            \int_step_inline:nnn { #3 } { #2 } {
                \dim_gset:Nn #4 { \dim_max:nn { #4 } { \seq_item:Nn #1 { ##1 } } }
            }
        }
    }
}

%
% MACROS FOR DRAWING PURPOSES
%
% Lines and arrows

% Arguments: 
%   #1: dim expression (something that can be evaluated by \dim_eval:n); the x-coordinate
%   #2: dim expression (something that can be evaluated by \dim_eval:n); the first y-coordinate
%   #3: dim expression (something that can be evaluated by \dim_eval:n); the second y-coordiante
% Function: Draws a vertical line from (#1,#2) to (#1,#3)
\cs_new:Npn \__gex_vline:nnn #1#2#3 {
    %\iow_log:n {TC:#2;#3}
    \dim_set:Nn \l_tmpa_dim { #3 }
    %\exp_args:Ne \iow_log:n { TA2: \dim_eval:n { \l_tmpa_dim } }
    \dim_sub:Nn \l_tmpa_dim { #2 }
    %\exp_args:Ne \iow_log:n { TA2: \dim_eval:n { \l_tmpa_dim } }
    \put(\dim_to_decimal:n { #1 }, \dim_to_decimal:n { \dim_min:nn { #2 } { #3 } }){\line(0,1){\dim_to_decimal:n { \dim_abs:n { \l_tmpa_dim } }}}
}

% Arguments:
%   #1: dim expression; the x-coordinate
%   #2: dim expression; the y-coordinate
%   #3: dim expression; the length of the vertical line 
% Function: Draws a vertical line from (#1,#2) to (#1,#2+#3). In particular #3 can be negative. Then the line is drawn to the south, otherwise to the north of (#1,#2)
\cs_new:Npn \__gex_vline_by_length:nnn #1#2#3 {
    \put(\dim_to_decimal:n { #1 }, \dim_to_decimal:n { #2 }){\line(0,1){\dim_to_decimal:n { #3 }}}
}

% Arguments:
%   #1: dim expression; the x-coordinate
%   #2: dim expression; the first y-coordinate
%   #3: dim expression; the second y-coordinate
% Function: Draws a vertical arrow from (#1,max(#2,#3)) to (#1,min(#2,#3)), i.e. always from top to bottom; 
% CAUTION: For this macro to not run infinitely, \g__gex_arrowht has to be non-zero
\cs_new:Npn \__gex_varrow:nnn #1#2#3 {
    \dim_set:Nn \l_tmpa_dim { #3 }
    \dim_sub:Nn \l_tmpa_dim { #2 }
    \__gex_cbox:nnn { #1 } { #2 } { \__gex_downarrow:n { \dim_eval:n { \l_tmpa_dim } } }
}

% Arguments:
%   #1: dim expression; the first x-coordinate
%   #2: dim expression; the y-coordinate
%   #3: dim expression; the second x-coordinate
% Function: Draws a horizontal line from (#1,#2) to (#3,#2)
\cs_new:Npn \__gex_hline:nnn #1#2#3 {
    \dim_set:Nn \l_tmpa_dim { #3 }
    \dim_sub:Nn \l_tmpa_dim { #1 }
    % \line CANNOT ABSORB NEGATIVE ARGUMENTS!!
    \put(\dim_to_decimal:n { \dim_min:nn { #1 } { #3 } }, \dim_to_decimal:n { #2 }){
        \line(1,0){\dim_to_decimal:n { \dim_abs:n { \l_tmpa_dim } }}
    }
}

% Arguments:
%   #1: dim expression; the x-coordinate
%   #2: dim expression; the y-coordinate
%   #3: dim expression; the length of the vertical line 
% Function: Draws a horizontal line from (#1,#2) to (#1+#3,#2). In particular #3 can be negative. Then the line is drawn to the west, otherwise to the east of (#1,#2)
\cs_new:Npn \__gex_hline_by_length:nnn #1#2#3 {
    \put(\dim_to_decimal:n { #1 }, \dim_to_decimal:n { #2 }){\line(1,0){\dim_to_decimal:n { #3 }}}
}

% Arguments:
%   #1: dim expression; the x-coordinate
%   #2: dim expression; the first y-coordinate
%   #3: dim expression; the second y-coordinate
% Function: Draws a vertical arrow from (max(#1,#3),#2) to (min(#1,#3),#2), i.e. always from right to left
\cs_new:Npn \__gex_harrow:nnn #1#2#3 {
    \dim_set:Nn \l_tmpa_dim { #3 }
    \dim_sub:Nn \l_tmpa_dim { #1 }
    \dim_add:Nn \l_tmpa_dim { 2pt } % This comes from gauss.sty: Why is this here?
    \__gex_rbox:nnn { #1 } { #2 } { \hbox_to_wd:nn { \l_tmpa_dim } { \leftarrowfill } }
}

% Boxes

% Arguments: 
%   #1: dim expression; 
%   #2: dim expression; 
%   #3: math content
% Function: Column box
\cs_new:Npn \__gex_cbox:nnn #1#2#3 {
    \hbox_set:Nn \g__gex_label { $\relax#3\relax$ }
    \hbox_set:Nn \g__gex_label { \box_move_up:nn { \box_dp:N \g__gex_label } { \box_use:N \g__gex_label } }
    \put(\dim_to_decimal:n { #1 }, \dim_to_decimal:n { #2 }){\makebox(0,0)[b]{\box_use:N \g__gex_label }}
}

% Arguments: 
%   #1: dim expression; 
%   #2: dim expression; 
%   #3: math content
% Function: Column box
\cs_new:Npn \__gex_rbox:nnn #1#2#3 {
    \hbox_set:Nn \g__gex_label { $\relax#3\relax$ }
    \box_set_ht:Nn \g__gex_label { 0pt }
    \box_set_dp:Nn \g__gex_label { 0pt }
    \hbox_set:Nn \g__gex_label { $\mathstrut\box_use:N \g__gex_label$ }
    \put(\dim_to_decimal:n { #1 }, \dim_to_decimal:n { #2 }){\makebox(0,0)[l]{\kern-1pt\box_use:N \g__gex_label}}
}

%
% COMMANDS FOR MATRIX OPERATIONS
%

% CAUTION: requires \colops to already be defined somewhere
\cs_new:Npn \__gex_north: {
    \__gex_endregion:
    \RenewDocumentCommand { \colops } { } { \PackageError{gauss}{Two~ sets~ of~ column~ operations~ are~ specified~ in~ just~ one~ matrix.~ This~ is~ not~ allowed.} }
    \cs_gset:Npn \__gex_endregion: {
            \end{picture}
        \egroup
        \hbox_gset:Nn \g__gex_northbox { \unhbox\l__gex_tmp_tex_box }
        % TODO: Take index shift of sequences into account!
        \__gex_get_max_over_range:NnnN \g__gex_cy { 1 } { \g__gex_maxcol+1 } { \l_tmpa_dim }
        \box_set_ht:Nn \g__gex_northbox { \l_tmpa_dim }
        \hbox_gset:Nn \g__gex_northbox { \box_move_up:nn { \l__gex_opt_colarrowsep } { \box_use:N \g__gex_northbox } }
    }
    % Use DeclareDocumentCommand because its not clear whether \colops or \rowops is called first, so neither New or Renew is suitable here. 
    \DeclareDocumentCommand { \swap } { O{} O{} m m } {
        \__gex_north_arrow:nnNNnnnn { 1 } { 1 } { \l__gex_opt_colswapfromlabel } { \l__gex_opt_colswaptolabel } { ##1 } { ##2 } { \int_eval:n { ##3+1 } } { \int_eval:n { ##4+1 } }
    }
    \DeclareDocumentCommand { \add } { O{} O{} m m } {
        \__gex_north_arrow:nnNNnnnn { 0 } { 1 } { \l__gex_opt_coladdfromlabel } { \l__gex_opt_coladdtolabel } { ##1 } { ##2 } { \int_eval:n { ##3+1 } } { \int_eval:n { ##4+1 } }
    }
    \DeclareDocumentCommand { \mult } { m m } {
        \__gex_north_mult:nn { ##1+1 } { ##2 }
    }
    \dim_set:Nn \l_tmpa_dim { 0pt }
    \setbox\l__gex_tmp_tex_box=\hbox\bgroup
        \begin{picture}(\dim_to_decimal:n { \g__gex_matrix_wd },0)(0,0)
            \linethickness{\dim_eval:n { \g__gex_linethickness } }
}

% Arguments: 
%   #1: int expression or *; 
%   #2: math content; 
\cs_new:Npn \__gex_north_mult:nn #1#2 {
    \str_if_eq:nnTF { #1 } { * } {
        \int_step_inline:nnn { 1 } { \g__gex_maxcol+1 } {
            \__gex_north_mult:nn { ##1 } { #2 }
        }
    }{
        \__gex_check_bounds:nnnn { c } { 1 } { #1 } { \g__gex_maxcol+1 }
        \if_bool:N \g__gex_index_in_bounds
            \__gex_cbox:nnn { \seq_item:Nn \g__gex_cx { #1 } } { \seq_item:Nn \g__gex_cy { #1 } } { \l__gex_opt_colmultlabel { #2 } }
            \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_cy { #1 } }
            \dim_add:Nn \l_tmpa_dim { \box_ht:N \g__gex_label }
            \exp_args:Ne \iow_log:n { TE:~ \dim_eval:n { \box_ht:N \g__gex_label }}
            \exp_args:NNne \seq_gset_item:Nnn \g__gex_cy { #1 } { \dim_eval:n { \l_tmpa_dim + \l__gex_opt_opskip } }
            % DEL: \g@update{sum}{cx#1}. 
        \fi:
    }
}

% DEL: \g@north@arrow, \gﬂnorth@arrow@a 

% Arguments: 
%   #1: Arrow at start position #7 (Yes: 1/No: 0)
%   #2: Arrow at end position #8 (Yes: 1/No: 0)
%   #3: Label at start position #7 (Function with one argument)
%   #4: Label at end position #8 (Function with one argument)
%   #5: The content of the start label (The argument that is given to the function #3)
%   #6: The content of the end label (The argument that is given to the function #4)
%   #7: Start position (int expression) or * 
%   #8: End position (int expression) or *
\cs_new:Npn \__gex_north_arrow:nnNNnnnn #1#2#3#4#5#6#7#8 {
    \str_if_eq:nnTF { #7 } { * } {
        \str_if_eq:nnTF { #8 } { * } {
            \int_step_inline:nnn { 1 } { \g__gex_maxcol+1 } {
                \__gex_north_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { * }
            }
        }{
            \int_step_inline:nnnn { #8 } { -1 } { 1 } {
                \__gex_north_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { #8 }
            }
            \int_step_inline:nnnn { #8 } { \g__gex_maxcol+1 } {
                \__gex_north_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { #8 }
            }
        }
    }{
        \str_if_eq:nnTF { #8 } { * } {
            \int_step_inline:nnnn { #7 } { -1 } { 1 } {
                \__gex_north_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { ##1 }
            }
            \int_step_inline:nnn { #7 } { \g__gex_maxcol+1 } {
                \__gex_north_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { ##1 }
            }
        } {
            \int_compare:nNnTF { #7 } = { #8 } {} {
                \__gex_check_bounds:nnnn { c } { 1 } { #7 } { \g__gex_maxcol+1 }
                \if_bool:N \g__gex_index_in_bounds 
                    \__gex_check_bounds:nnnn { c } { 1 } { #8 } { \g__gex_maxcol+1 }
                    \if_bool:N \g__gex_index_in_bounds
                        \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_cy { #7 } }
                        \dim_set:Nn \l_tmpb_dim { \seq_item:Nn \g__gex_cy { #8 } }
                        \str_if_eq:nnTF { #1 } { 0 } {
                            \exp_args:Ne \iow_log:n { TB1:\seq_item:Nn \g__gex_cy { #7 } }
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_cy { #7 } { \dim_eval:n { \l_tmpa_dim + \l__gex_opt_colopminsize } }
                            \exp_args:Ne \iow_log:n { TB2:\seq_item:Nn \g__gex_cy { #7 } }
                        }{
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_cy { #7 } { \dim_eval:n { \l_tmpa_dim + \g__gex_arrowht } }
                        }
                        \str_if_eq:nnTF { #2 } { 0 } {
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_cy { #8 } { \dim_eval:n { \l_tmpb_dim + \l__gex_opt_colopminsize } }
                        } {
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_cy { #8 } { \dim_eval:n { \l_tmpb_dim + \g__gex_arrowht } }
                        }
                        \seq_log:N \g__gex_cy
                        \__gex_get_max_over_range:NnnN \g__gex_cy { #7 } { #8 } \g__gex_tmp_dim
                        \dim_log:N \g__gex_tmp_dim
                        \str_if_eq:nnTF { #1 } { 0 } {
                            \iow_log:n { TA1 }
                            \exp_args:Ne \iow_log:n { \dim_eval:n { \l_tmpa_dim }}
                            \exp_args:Ne \iow_log:n { \dim_eval:n { \g__gex_tmp_dim }}
                            \exp_args:Neee \__gex_vline:nnn { \seq_item:Nn \g__gex_cx { #7 } } { \dim_eval:n { \l_tmpa_dim } } { \dim_eval:n { \g__gex_tmp_dim } }
                        } {
                            \exp_args:Neee \__gex_varrow:nnn { \seq_item:Nn \g__gex_cx { #7 } } { \dim_eval:n { \l_tmpa_dim } } { \dim_eval:n { \g__gex_tmp_dim } }
                        }
                        \str_if_eq:nnTF { #2 } { 0 } {
                            \exp_args:Neee \__gex_vline:nnn { \seq_item:Nn \g__gex_cx { #8 } } { \dim_eval:n { \l_tmpb_dim } } { \dim_eval:n { \g__gex_tmp_dim } }
                        } {
                            \exp_args:Neee \__gex_varrow:nnn { \seq_item:Nn \g__gex_cx { #8 } } { \dim_eval:n { \l_tmpb_dim } } { \dim_eval:n { \g__gex_tmp_dim } }
                        }
                        \exp_args:Neee \__gex_hline:nnn { \seq_item:Nn \g__gex_cx { #7 } } { \dim_eval:n { \g__gex_tmp_dim } } { \seq_item:Nn \g__gex_cx { #8 } }
                        \hbox_set:Nn \l_tmpa_box { $#3{#5}$ }
                        \hbox_set:Nn \l_tmpb_box { $#4{#5}$ }
                        \dim_compare:nNnTF { \box_ht:N \l_tmpa_box } > { 0pt } {
                            \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_labelskip }
                        } {
                            \dim_compare:nNnTF { \box_ht:N \l_tmpb_box } > { 0pt } {
                                \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_labelskip }
                            } {}
                        }
                        \dim_set:Nn \g__gex_tmpc_dim { 0pt }
                        \dim_compare:nNnTF { \box_ht:N \l_tmpa_box } > { 0pt } {
                            \exp_args:Neee \__gex_cbox:nnn { \seq_item:Nn \g__gex_cx { #7 } } { \g__gex_tmp_dim } { \kern-1pt\vcenter{\box_use:N \l_tmpa_box} }
                            \dim_set:Nn \g__gex_tmpc_dim { \box_ht:N \g__gex_label }
                            \exp_args:Ne \iow_log:n { TD:~ \dim_eval:n { \g__gex_tmpc_dim } }
                        } {}
                        \dim_compare:nNnTF { \box_ht:N \l_tmpb_box } > { 0pt } {
                            \exp_args:Neee \__gex_cbox:nnn { \seq_item:Nn \g__gex_cx { #8 } } { \g__gex_tmp_dim } { \kern-1pt\vcenter{\box_use:N \l_tmpb_box} }
                            \dim_compare:nNnTF { \box_ht:N \g__gex_label } > { \g__gex_tmpc_dim } {
                                \dim_set:Nn \g__gex_tmpc_dim { \box_ht:N \g__gex_label }
                            } {}
                        } {}
                        \dim_add:Nn \g__gex_tmp_dim { \g__gex_tmpc_dim }
                        \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_opskip }
                        % TODO: Implement generally as \__gex_set_range_to_max_rsp (rsp = respecfively)
                        \int_compare:nNnTF { #7 } < { #8 } {
                            \int_step_inline:nnn { #7 } { #8 } {
                                \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_cy { ##1 } }
                                \exp_args:NNNe \seq_gset_item:Nnn \g__gex_cy { ##1 } { \dim_max:nn { \l_tmpa_dim } { \g__gex_tmp_dim } }
                            }
                        } {
                            \int_step_inline:nnn { #8 } { #7 } {
                                \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_cy { ##1 } }
                                \exp_args:NNNe \seq_gset_item:Nnn \g__gex_cy { ##1 } { \dim_max:nn { \l_tmpa_dim } { \g__gex_tmp_dim } }
                            }
                        }
                    \fi: 
                \fi: 
            }
        }
    }
}

% MISSING: Implementation for east (but this comes after testing the north region)
% CAUTION: requires \rowops to already be defined somewhere
\cs_new:Npn \__gex_east: {
    \__gex_endregion:
    \RenewDocumentCommand { \rowops } { } { \PackageError{gauss}{Two~ sets~ of~ row~ operations~ were~ specified~ in~ just~ one~ matrix.~ This~ is~ not~ allowed.} }
    % DEL: \g@defdim{sum}{\z@}%
    \cs_gset:Npn \__gex_endregion: {
            \end{picture}
        \egroup
        \hbox_gset:Nn \g__gex_eastbox { \unhbox\l__gex_tmp_tex_box }
        % TODO: Take index shift of sequences into account!
        \__gex_get_max_over_range:NnnN \g__gex_rx { 1 } { \g__gex_maxrow+1 } { \l_tmpa_dim }
        \box_gset_wd:Nn \g__gex_eastbox { \l_tmpa_dim } % CAUTION: this is not global in gauss.sty!
    }
    % Use DeclareDocumentCommand because its not clear whether \colops or \rowops is called first, so neither New or Renew is suitable here. 
    \DeclareDocumentCommand { \swap } { O{} O{} m m } {
        \__gex_east_arrow:nnNNnnnn { 1 } { 1 } { \l__gex_opt_rowswapfromlabel } { \l__gex_opt_rowswaptolabel } { ##1 } { ##2 } { \int_eval:n { ##3+1 } } { \int_eval:n { ##4+1 } }
    }
    \DeclareDocumentCommand { \add } { O{} O{} m m } {
        \__gex_east_arrow:nnNNnnnn { 0 } { 1 } { \l__gex_opt_rowaddfromlabel } { \l__gex_opt_rowaddtolabel } { ##1 } { ##2 } { \int_eval:n { ##3+1 } } { \int_eval:n { ##4+1 } }
    }
    \DeclareDocumentCommand { \mult } { m m } {
        \__gex_east_mult:nn { ##1+1 } { ##2 }
    }
    \dim_set:Nn \l_tmpa_dim { 0pt }
    \setbox\l__gex_tmp_tex_box=\hbox\bgroup
        \begin{picture}(0,\dim_to_decimal:n { \g__gex_matrix_ht })(0,0)
            \linethickness{\dim_eval:n { \g__gex_linethickness } }
}

% Arguments: 
%   #1: int expression or *; 
%   #2: math content; 
\cs_new:Npn \__gex_east_mult:nn #1#2 {
    \str_if_eq:nnTF { #1 } { * } {
        \int_step_inline:nnn { 1 } { \g__gex_maxrow+1 } {
            \__gex_east_mult:nn { ##1 } { #2 }
        }
    }{
        \__gex_check_bounds:nnnn { c } { 1 } { #1 } { \g__gex_maxrow+1 }
        \if_bool:N \g__gex_index_in_bounds
            \__gex_rbox:nnn { \seq_item:Nn \g__gex_rx { #1 } } { \seq_item:Nn \g__gex_ry { #1 } } { \l__gex_opt_rowmultlabel { #2 } }
            \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_rx { #1 } }
            \dim_add:Nn \l_tmpa_dim { \box_wd:N \g__gex_label }
            \exp_args:NNne \seq_gset_item:Nnn \g__gex_rx { #1 } { \dim_eval:n { \l_tmpa_dim + \l__gex_opt_labelskip } } % maybe here use \opskip and not \labelskip 
            % DEL: \g@update{sum}{rx#1}. 
        \fi:
    }
}

% Arguments: 
%   #1: Arrow at start position #7 (Yes: 1/No: 0)
%   #2: Arrow at end position #8 (Yes: 1/No: 0)
%   #3: Label at start position #7 (Function with one argument)
%   #4: Label at end position #8 (Function with one argument)
%   #5: The content of the start label (The argument that is given to the function #3)
%   #6: The content of the end label (The argument that is given to the function #4)
%   #7: Start position (int expression) or * 
%   #8: End position (int expression) or *
\cs_new:Npn \__gex_east_arrow:nnNNnnnn #1#2#3#4#5#6#7#8 {
    \str_if_eq:nnTF { #7 } { * } {
        \str_if_eq:nnTF { #8 } { * } {
            \int_step_inline:nnn { 1 } { \g__gex_maxrow+1 } {
                \__gex_east_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { * }
            }
        }{
            \int_step_inline:nnnn { #8 } { -1 } { 1 } {
                \__gex_east_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { #8 }
            }
            \int_step_inline:nnnn { #8 } { \g__gex_maxrow+1 } {
                \__gex_east_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { ##1 } { #8 }
            }
        }
    }{
        \str_if_eq:nnTF { #8 } { * } {
            \int_step_inline:nnnn { #7 } { -1 } { 1 } {
                \__gex_east_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { ##1 }
            }
            \int_step_inline:nnn { #7 } { \g__gex_maxrow+1 } {
                \__gex_east_arrow:nnNNnnnn { #1 } { #2 } { #3 } { #4 } { #5 } { #6 } { #7 } { ##1 }
            }
        } {
            \int_compare:nNnTF { #7 } = { #8 } {} {
                \__gex_check_bounds:nnnn { c } { 1 } { #7 } { \g__gex_maxrow+1 }
                \if_bool:N \g__gex_index_in_bounds 
                    \__gex_check_bounds:nnnn { c } { 1 } { #8 } { \g__gex_maxrow+1 }
                    \if_bool:N \g__gex_index_in_bounds
                        \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_rx { #7 } }
                        \dim_set:Nn \l_tmpb_dim { \seq_item:Nn \g__gex_rx { #8 } }
                        \str_if_eq:nnTF { #1 } { 0 } {
                            \exp_args:Ne \iow_log:n { TB1:\seq_item:Nn \g__gex_rx { #7 } }
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_rx { #7 } { \dim_eval:n { \l_tmpa_dim + \l__gex_opt_rowopminsize } }
                            \exp_args:Ne \iow_log:n { TB2:\seq_item:Nn \g__gex_rx { #7 } }
                        }{
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_rx { #7 } { \dim_eval:n { \l_tmpa_dim + \g__gex_arrowwd } }
                        }
                        \str_if_eq:nnTF { #2 } { 0 } {
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_rx { #8 } { \dim_eval:n { \l_tmpb_dim + \l__gex_opt_rowopminsize } }
                        } {
                            \exp_args:NNne \seq_gset_item:Nnn \g__gex_rx { #8 } { \dim_eval:n { \l_tmpb_dim + \g__gex_arrowwd } }
                        }
                        \seq_log:N \g__gex_rx
                        \__gex_get_max_over_range:NnnN \g__gex_rx { #7 } { #8 } \g__gex_tmp_dim
                        \dim_log:N \g__gex_tmp_dim
                        \str_if_eq:nnTF { #1 } { 0 } {
                            \iow_log:n { TA1 }
                            \exp_args:Ne \iow_log:n { \dim_eval:n { \l_tmpa_dim }}
                            \exp_args:Ne \iow_log:n { \dim_eval:n { \g__gex_tmp_dim }}
                            \exp_args:Neee \__gex_hline:nnn { \dim_eval:n { \l_tmpa_dim } } { \seq_item:Nn \g__gex_ry { #7 } } { \dim_eval:n { \g__gex_tmp_dim } }
                        } {
                            \exp_args:Neee \__gex_harrow:nnn { \dim_eval:n { \l_tmpa_dim } } { \seq_item:Nn \g__gex_ry { #7 } } { \dim_eval:n { \g__gex_tmp_dim } }
                        }
                        \str_if_eq:nnTF { #2 } { 0 } {
                            \exp_args:Neee \__gex_hline:nnn { \dim_eval:n { \l_tmpb_dim } } { \seq_item:Nn \g__gex_ry { #8 } } { \dim_eval:n { \g__gex_tmp_dim } }
                        } {
                            \exp_args:Neee \__gex_harrow:nnn { \dim_eval:n { \l_tmpb_dim } } { \seq_item:Nn \g__gex_ry { #8 } } { \dim_eval:n { \g__gex_tmp_dim } }
                        }
                        \exp_args:Neee \__gex_vline:nnn { \g__gex_tmp_dim } { \seq_item:Nn \g__gex_ry { #7 } } { \seq_item:Nn \g__gex_ry { #8 } }
                        \hbox_set:Nn \l_tmpa_box { $#3{#5}$ }
                        \hbox_set:Nn \l_tmpb_box { $#4{#5}$ }
                        \dim_compare:nNnTF { \box_wd:N \l_tmpa_box } > { 0pt } {
                            \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_labelskip }
                        } {
                            \dim_compare:nNnTF { \box_wd:N \l_tmpb_box } > { 0pt } {
                                \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_labelskip }
                            } {}
                        }
                        \dim_set:Nn \g__gex_tmpc_dim { 0pt }
                        \dim_compare:nNnTF { \box_wd:N \l_tmpa_box } > { 0pt } {
                            \exp_args:Neee \__gex_rbox:nnn { \g__gex_tmp_dim } { \seq_item:Nn \g__gex_ry { #7 } } { \kern-1pt\vcenter{\box_use:N \l_tmpa_box} }
                            \dim_set:Nn \g__gex_tmpc_dim { \box_wd:N \g__gex_label }
                        } {}
                        \dim_compare:nNnTF { \box_wd:N \l_tmpb_box } > { 0pt } {
                            \exp_args:Neee \__gex_rbox:nnn { \g__gex_tmp_dim } { \seq_item:Nn \g__gex_ry { #8 } } { \kern-1pt\vcenter{\box_use:N \l_tmpb_box} }
                            \dim_compare:nNnTF { \box_wd:N \g__gex_label } > { \g__gex_tmpc_dim } {
                                \dim_set:Nn \g__gex_tmpc_dim { \box_wd:N \g__gex_label }
                            } {}
                        } {}
                        \dim_add:Nn \g__gex_tmp_dim { \g__gex_tmpc_dim }
                        \dim_add:Nn \g__gex_tmp_dim { \l__gex_opt_opskip }
                        % TODO: Implement generally as \__gex_set_range_to_max_rsp (rsp = respecfively)
                        \int_compare:nNnTF { #7 } < { #8 } {
                            \int_step_inline:nnn { #7 } { #8 } {
                                \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_rx { ##1 } }
                                \exp_args:NNNe \seq_gset_item:Nnn \g__gex_rx { ##1 } { \dim_max:nn { \l_tmpa_dim } { \g__gex_tmp_dim } }
                            }
                        } {
                            \int_step_inline:nnn { #8 } { #7 } {
                                \dim_set:Nn \l_tmpa_dim { \seq_item:Nn \g__gex_rx { ##1 } }
                                \exp_args:NNNe \seq_gset_item:Nnn \g__gex_rx { ##1 } { \dim_max:nn { \l_tmpa_dim } { \g__gex_tmp_dim } }
                            }
                        }
                    \fi: 
                \fi: 
            }
        }
    }
}

%
% MATRIX ENVIRONMENTS
%
\NewDocumentEnvironment { gexmatrix } { O{} } {
    \unitlength=1pt%
    %\tl_set:Nn \l__gex_environment { #1matrix }
    \bool_set_true:N \l__gex_in_env 
    \keys_set:nn { gex } { 
        #1 
    }
    \bool_set_false:N \l__gex_in_env % not needed as the previous assignment is local 
    \begin{__gex_matrix}
} {
    \end{__gex_matrix}
    % \cs_set_eq:Nc \matrix { } % \let\matrix\@empty
    % \cs_set_eq:Nc \endmatrix { } % \let\endmatrix\@empty
    \dim_set:Nn \g__gex_tmpa_dim { \box_ht:N \g__gex_matrixbox }
    \dim_add:Nn \g__gex_tmpa_dim { 1pt }
    \dim_set:Nn \g__gex_tmpb_dim { \box_dp:N \g__gex_matrixbox }
    \dim_add:Nn \g__gex_tmpb_dim { 1pt }
    \dim_set:Nn \g__gex_tmp_dim { \box_ht:N \g__gex_northbox }
    \box_set_ht:Nn \g__gex_northbox { 0pt }
    \box_set_dp:Nn \g__gex_northbox { 0pt }
    \dim_compare:nNnTF { \g__gex_tmp_dim } > { 0pt } {
        \dim_sub:Nn \g__gex_tmp_dim { \l__gex_opt_opskip }
    } {}
    \dim_add:Nn \g__gex_tmp_dim { .5 \box_ht_plus_dp:N \g__gex_matrixbox }
    \begin{ pmatrix }
        \vcenter{
            \hbox {
                \rlap{
                    \box_move_up:nn { \box_ht:N \g__gex_matrixbox } { \box_use:N \g__gex_northbox }
                    % \box_move_up:nn { \box_ht:N \g__gex_matrixbox } { \hbox:n {
                    %     \rule{43.14pt}{.2pt}
                    % } }
                }
                \rule{0pt}{\dim_eval:n { \g__gex_tmpa_dim }}
                \box_move_down:nn { \g__gex_tmpb_dim } { \null }
                \box_use:N \g__gex_matrixbox
                % \box_move_down:nn { \box_dp:N \g__gex_matrixbox } { \hbox:n { \rule{.2pt}{9.36pt}\rule{.2pt}{36.67pt} } }
            }
        } 
    \end{ pmatrix }
    \rule{\dim_eval:n { \l__gex_opt_rowarrowsep } }{0pt}
    \rule{0pt}{\dim_eval:n { \g__gex_tmp_dim }}
    \vcenter{
        \hbox:n {
            \exp_args:Ne \iow_log:n { TC2:~\dim_eval:n { \box_wd:N \g__gex_eastbox } }
            \box_move_down:nn { \g__gex_matrix_dp } { \box_use:N \g__gex_eastbox }
        }
    }
}

\cs_new:Npn \__gex_endmatrix: {
            \mathstrut\crcr
        \c_group_end_token
    \egroup
    \box_gset_to_last:N \g__gex_matrixbox
    \__gex_measure_axis:
    \vbox_set:Nn \g__gex_trash {
        \vbox_unpack:N \g__gex_matrixbox
        \box_gset_to_last:N \g__gex_eastbox % save the last row
        \box_use:N \g__gex_eastbox
        \dim_set:Nn \g__gex_tmp_dim { 0pt }
        {
            \__gex_measure_rows:
            \seq_log:N \g__gex_ry
        }
    }
    \hbox_set:Nn \g__gex_trash {
        \hbox_to_wd:nn { 100cm } { .\hfill. }
        % \box_log:N \g__gex_eastbox
        \hbox_unpack:N \g__gex_eastbox
        \box_gclear:N \g__gex_eastbox % hbox_unpack = unhcopy not unhbox
        \dim_set:Nn \g__gex_tmp_dim { 0pt }
        {
            \__gex_measure_cols:
            \seq_log:N \g__gex_cx
        }
    } 
    \dim_gset:Nn \g__gex_matrix_ht { \box_ht_plus_dp:N \g__gex_matrixbox }
    \dim_gset:Nn \g__gex_matrix_wd { \box_wd:N \g__gex_matrixbox }
    \dim_gset:Nn \g__gex_matrix_dp { \box_dp:N \g__gex_matrixbox }
}

\cs_new:Npe \__gex_prae: { \hfil\noexpand\mathstrut$\relax }
\cs_new:Npe \__gex_post: { \relax$\hfil }
% Unsure about how to implement private "helper" environments as the next one in expl3
\NewDocumentEnvironment { __gex_matrix } {} {
    \setbox\l__gex_tmp_tex_box=\hbox\bgroup
        \int_gset:Nn \g__gex_maxrow_old { \g__gex_maxrow }
        \int_gset:Nn \g__gex_maxcol_old { \g__gex_maxcol }
        \int_gset:Nn \g__gex_maxrow { 0 }
        \int_gset:Nn \g__gex_maxcol { 0 }
        \cs_gset_eq:NN \rowops \__gex_east:
        \cs_gset_eq:NN \colops \__gex_north:
        \vbox \bgroup
            \RenewDocumentCommand { \\ } {} {
                \mathstrut
                \cr
                \int_gincr:N \g__gex_maxrow
                \relax
            }
            \cs_gset_eq:NN \__gex_endregion: \__gex_endmatrix:
            \dim_gset:Nn \g__gex_tab { 2\arraycolsep } % this is different from 2\the\arraycolsep because then its just 2 + 5pt (string concatenation)
            \ialign\c_group_begin_token\__gex_prae:##\__gex_post:&&\skip_horizontal:n { \g__gex_tab }\__gex_prae:##\__gex_post:\cr 
} {
        \__gex_endregion:
    \egroup
    \hbox_set:Nn \g__gex_trash { \unhbox\l__gex_tmp_tex_box }
    \int_gset_eq:NN \g__gex_maxrow \g__gex_maxrow_old
    \int_gset_eq:NN \g__gex_maxcol \g__gex_maxcol_old
    \cs_gset_eq:NN \__gex_endregion: \__gex_endmatrix: 
    \cs_gset_eq:NN \rowops \__gex_east:
    \cs_gset_eq:NN \colops \__gex_north:
    % CAUTION: quick fix
    \seq_gclear:N \g__gex_cy
    \seq_gclear:N \g__gex_rx
}

\ExplSyntaxOff

\def\coladdfromlabel#1{\scriptstyle #1}
\def\coladdtolabel#1{\scriptscriptstyle +}

\endinput