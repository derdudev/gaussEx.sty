\ProvidesPackage{gaussEx}[2025/03/02]
\RequirePackage{amsmath}
\RequirePackage{expl3}

\ExplSyntaxOn
%
% VARIABLES
%
% Boxes
\box_new:N \g__gex_trash
\box_new:N \g__gex_matrixbox
\box_new:N \g__gex_eastbox
\box_new:N \g__gex_northbox
\box_new:N \g__gex_centerbox % NEW
\box_new:N \g__gex_label
\box_new:N \g__gex_tmp_box
\box_new:N \g__gex_tmpa_box
\box_new:N \g__gex_tmpb_box

% Integers
\int_new:N \g__gex_maxrow
\int_new:N \g__gex_maxcol
\int_new:N \g__gex_maxrow_old
\int_new:N \g__gex_maxcol_old
\int_new:N \g__gex_tmp_int % in gauss: g@c@tmp
\int_new:N \g__gex_tmpa_int % g@c@tmpa

% Dimensions
\dim_new:N \g__gex_axis_height
\dim_new:N \g__gex_linethickness
\dim_new:N \g__gex_tab
\dim_new:N \g__gex_arrowht
\dim_new:N \g__gex_arrowwd
\dim_new:N \g__gex_tmp_dim
\dim_new:N \g__gex_tmpa_dim
\dim_new:N \g__gex_tmpb_dim
\dim_new:N \g__gex_tmpc_dim
\dim_new:N \g__gex_tmpd_dim
\dim_new:N \g__gex_tmpe_dim

% DEL: The \g@for macro does not need to be implemented as its functionality should be given by \int_step_inline

% Bounds check
\bool_new:N \g__gex_index_in_bounds
% Arguments:
%   #1: Either the token "r" or "c"; "r" causes an Row-Bounds-Error to be thrown, "c" causes an Colum-Bounds-Error to be thrown
%   #2: Integer 
%   #3: Integer
%   #4: Integer
% Function: Sets \g__gex_index_in_bounds to true if #2<=#3<=#4 and to false if not
\cs_new:Npn \__gex_check_bounds:nnnn #1#2#3#4 {
    \bool_set_false:N \g__gex_index_in_bounds
    % using \int_compare:nTF would result in clearer code, but a huge performance loss (5x slower that \int_compare:nNnTF)
    \int_compare:nNnTF #2 > #3 {
        \PackageError{gaussEx}{\__gex_short_bounds_error:n { #1 }~ #2>#3}{\__gex_long_bounds_error:n { #1 }}
    }{
        \int_compare:nNnTF #3 > #4 {
            \PackageError{gaussEx}{\__gex_short_bounds_error:n { #1 }~ #3>#4}{\__gex_long_bounds_error:n { #1 }}
        }{
            \bool_set_true:N \g__gex_index_in_bounds
        }
    }
}

% Arguments: 
%   #1: Either "r" (Row-Bounds-Error) or "c" (Column-Bounds-Error)
\cs_new:Npn \__gex_short_bounds_error:n #1 {
    \str_if_eq:nnTF { r } { #1 } { Row~ } { Column~ }
    index~ out~ of~ bounds:
}
% Arguments: 
%   #1: Either "r" (Row-Bounds-Error)) or "c" (Column-Bounds-Error)
\cs_new:Npn \__gex_long_bounds_error:n #1 {
    An~index~of~an~operation~points~to~a~
    \str_if_eq:nnTF { r } { #1 } { row~ } { column~ }
    that~ does~ not~ exist.\MessageBreak
    Note~ that~ the~ index~ of~ the~ 
    \str_if_eq:nnTF { r } { #1 } { bottom~ row~ } { leftmost~ column~ }
    is~ 0~ while~ the~ index~ of~ the~
    \str_if_eq:nnTF { r } { #1 } { top~ row~ } { rightmost~ column~ }
    is~ <number~ of~
    \str_if_eq:nnTF { r } { #1 } { rows~ } { columns~ } 
    -~ 1>.
}

%
% BUILD THE VERTICAL ARROW
%
\DeclareMathSymbol{\__gex_downarrow_symb:}{\mathord}{largesymbols}{`\y}
\DeclareMathSymbol{\__gex_vertline_symb:}{\mathord}{largesymbols}{`\?}
\cs_new:Npn \__gex_vertline: { \hbox:n { $\__gex_vertline_symb:$ }\kern-\lineskip }

\cs_new:Npn \__gex_downarrow:n #1 {
    \vbox:n {
        \vfill 
        \baselineskip0pt
        \dim_set:Nn \g__gex_tmpc_dim { #1 }
        \dim_compare:nNnTF { \g__gex_tmpc_dim } < { \g__gex_arrowht } {
            \dim_set_eq:NN \g_g_ex_tmpc_dim \g__gex_arrowht
        }{}
        \__gex_arrow_vline:
        \kern\dim_eval:n { \g__gex_tmpc_dim }
        \hbox_set:Nn \g__gex_trash { $\__gex_downarrow_symb:$ }
        \hbox:n { \box_move_up:nn { \box_dp:N \g__gex_trash } { \box_use:N \g__gex_trash } }
    }
}
\cs_new:Npn \__gex_arrow_vline: {
    \dim_sub:Nn \g__gex_tmpc_dim { \g__gex_arrowht }
    \dim_compare:nNnTF { \g__gex_tmpc_dim } < { 0pt } { } {
        \__gex_vertline:
        \__gex_arrow_vline:
    }
}

% DEL: \redo, \g@del (\dim_to_decimal), \g@defdim (\dim_set), \g@defdouble (\fp_set), \g@dim (\fp_to_dim), \g@double (\fp_eval:n, \dim_eval:n), \g@advance (\dim_add, \fp_add), \g@min (\dim_min and \fp_min), \g@minD , \g@max, \g@maxD, \g@dist (\dim_sub, \fp_sub), \g@distD, \g@update (replace as moving along), \g@updateArea (implement first later, then see)

\seq_new:N \g__gex_rx
\seq_new:N \g__gex_ry
\seq_new:N \g__gex_rb
\seq_new:N \g__gex_rt
\cs_new:Npn \__gex_measure_rows: {
    \box_set_to_last:N \g__gex_trash
    \int_compare:nNnTF { \g__gex_maxrow } < { 0 } {} {
        \dim_compare:nNnTF { \box_ht:N \g__gex_trash } = { 0pt } {
            \dim_add:Nn \g__gex_tmp_dim { \lastskip }
            \unskip
            \dim_add:Nn \g__gex_tmp_dim { \lastkern }
            \unkern
            \unpenalty
        }{
            \dim_add:Nn \g__gex_tmp_dim { \box_dp:N \g__gex_trash }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rb { \dim_eval:n { \g__gex_tmp_dim } }
            \dim_add:Nn \g__gex_tmp_dim { \g__gex_axis_height }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_ry { \dim_eval:n { \g__gex_tmp_dim } }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rx { \c_zero_dim }
            \dim_sub:Nn \g__gex_tmp_dim { \g__gex_axis_height }
            \dim_add:Nn \g__gex_tmp_dim { \box_ht:N \g__gex_trash }
            \exp_args:NNe \seq_gput_left:Nn \g__gex_rt { \dim_eval:n { \g__gex_tmp_dim } }
            \int_decr:N \g__gex_maxrow
        }
        \__gex_measure_rows:
    }
}



\cs_new:Npn \__gex_measure_axis: {
    \hbox_set:Nn \g__gex_trash { $\vcenter{\hbox to 5pt{}}$ }
    \dim_gset:Nn \g__gex_axis_height { \box_ht:N \g__gex_trash }
}


\ExplSyntaxOff
\endinput